# Music Theory & Analytics API — Full Specification & Design Document

This document consolidates **all decisions made so far** across the discovery, architecture, and detailed design phases. It defines the full v1 system (local-first API) and the long-term direction (template DSL, form-driven planning, harmonic + melodic engines).

---

# 1. Product Direction

* Local-first API running on user’s machine, optionally deployable remotely.
* Core value: deep musical analysis + structured harmonic/melodic generation.
* v1 optimized for jazz, neo-soul, funk, gospel, fusion; secondary: pop/rock/R&B/EDM.
* Input: symbolic + MIDI; audio explicitly excluded in v1.
* Non-functional priorities: correctness → explainability → experimentation → latency.

---

# 2. Workspace Structure

Single Rust workspace with crates:

* **music-core** — pitch, intervals, scales, chords, keys, meter, tuning.
* **music-structure** — phrases, cadences, motifs, sections, form.
* **music-analysis** — orchestrated harmonic/melodic analysis.
* **music-api** — HTTP/WS/SSE, persistence, JSON models.
* **music-cli** — local tool for testing & benchmarking.

All crates Rust 2024 edition, resolver 3, strict linting.

---

# 3. Timing Model: Hybrid Raw + Grid Layer (Locked)

## Raw Layer

Preserves 100% input fidelity.

* `RawNote` contains exact onsets/durations.
* `RawTrack` contains notes + tempo/meter maps.
* `RawSession` bundles tracks + metadata.

## Grid Layer

Used for all analysis.

* Notes are snapped to grid while preserving raw deltas.
* Swing inference automatically detected.
* Grid-based chord/phrase/section detection.
* Preserves expressive feel via `timing_delta`.

---

# 4. Symbolic Graph + Structure Model

* Harmonic events with: chord, function, key estimate, confidence.
* Phrases with: expected functions, cadences.
* Sections with: templates and form rules.
* Entire song represented as a `StructureGraph`.

---

# 5. Analysis Engine

## Config

* Explainability: none / brief / detailed / debug.
* Style profile (jazz, neo-soul, funk, gospel, etc.).
* Creativity: risk, tension bias, voice-leading strictness, reharm depth.
* Timing: latency + event limits.
* User form template ID.

## Outputs

* Key/meter/chord tracks.
* Structure detection.
* **4–8 bar harmonic progression planning (full form-driven).**
* **Melodic motifs (harmony-derived for v1).**
* Explainability payload.

---

# 6. Style System: Rule Graph (Locked)

Each style is a structured graph of:

* Global rules
* Context rules
* Move rules (functional transitions)
* Weight rules
* Constraint rules
* Transformation rules (reharmonizations)

Creativity settings adjust risk, tension, reharm depth, and voice leading.

---

# 7. Harmonic Generation: Full Form-Driven Planning (Locked)

Planner generates **4–8 bar** sections using:

* Beam search (width 6–12, depth 4–8).
* Harmonic states containing key, function, chord, bar index, tension, phrase progress.
* Tension curves from templates.
* Mandatory cadences.
* Modulation rules.
* Phrase boundaries.
* Reharm zones.

Planner strictly follows **section templates**.

---

# 8. User-Defined Template DSL (Locked)

Users can upload custom form templates specifying:

* Bar count
* Phrases (start/end + expected functions + cadence)
* Tension curves (constant/curve/segmented)
* Modulation behavior
* Constraints (parallel 5ths, chromatic mediants, etc.)
* Reharmonization zones

Format: JSON5 or RON.

### Validation

* Phrases must not overlap.
* All bar numbers valid.
* Tension curve matches bar count.
* Cadences consistent.
* Constraints legal.

### Compilation

* Convert DSL → internal `SectionTemplate` with precomputed bar rules.

---

# 9. Template Registry (Locked)

Templates stored server-side.

## API

* `POST /v1/templates` — upload DSL → validate → compile → store.
* `GET /v1/templates` — list.
* `GET /v1/templates/{id}` — return raw + compiled.
* `DELETE /v1/templates/{id}`.

Limits:

* Max 100 templates
* Max 64 bars
* Max 64KB raw

---

# 10. Single Template Per Analysis (Locked)

* v1 uses one template per run.
* Ensures coherence and simpler explainability.
* Future versions can support sequences.

---

# 11. Melodic Generation (Locked: A)

v1 melodic engine = **harmony-derived** motifs.

* Motifs from scale degrees, chord tones, passing tones.
* Contours matched to tension curve.
* Cadential resolution enforced.
* Fully explainable (“starts on 3rd, approaches 9th, resolves to 1 on cadence”).

Long-term: optional melodic DSL.

---

# 12. External API

## REST

* `POST /v1/analyze` — main synchronous analysis.
* `POST /v1/analyze/stream` — SSE streaming.
* `GET /v1/runs/{id}` — retrieve stored analysis.
* `GET /v1/presets` — style profiles.
* `GET /v1/health`.

## WebSocket

* `/ws/analyze` with `start`, `progress`, `update`, `completed`, `error`, `cancel`.

---

# 13. Persistence

* Stateless engine with optional run storage.
* RunStore trait for in-memory or external DB.
* StoredRun contains config + summary.

---

# 14. Explainability

Explain modes:

* **none** — no explanations.
* **brief** — highlights only.
* **detailed** — per-bar/per-chord reasoning.
* **debug** — internal traces (feature gated).

Explain references:

* Template ID
* Fired rules
* Tension curve targets
* Voice-leading decisions
* Reharm decisions
* Cadence validation

---

# 15. Performance Targets

* Target <300 ms typical analysis.
* Cap event count.
* Beam pruning + caching for planning.
* Precompiled templates.
* Parallelizable where safe.

---

# 16. Testing

* Golden tests: MIDI → expected chord/key/structure.
* Template tests: DSL validation.
* Planner regression tests: harmonic sequences remain stable.
* API integration tests.

---

# 17. Long-term Evolution

* Melody DSL (future)
* Multi-template sequences per run
* Audio-mode (future)
* ML-enhanced variants (optional)
* Larger library of form templates

---

# End of Document
