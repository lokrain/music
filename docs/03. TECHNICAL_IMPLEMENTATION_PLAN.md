# Music Theory & Analytics API — Technical Implementation Plan (v1)

This document defines **how** to implement the v1 system described in `01. DISCOVERY_SUMMURY.md` and `02. SPECIFICATION_AND_DESIGN.md`.

---

## 1. Repository & Workspace Structure

### 1.1. Monorepo layout

Rust workspace (edition 2024, resolver 3):

```text
music-workspace/
  Cargo.toml          # workspace, lint config, shared features
  rust-toolchain.toml # pinned toolchain
  justfile            # tasks (lint, test, fmt, benches)
  .cargo/
    config.toml       # resolver=3, shared flags
  crates/
    music-core/
    music-structure/
    music-analysis/
    music-api/
    music-cli/
  tests/
    api/
    analysis/
    templates/
```

### 1.2. Crate responsibilities

* `music-core`

  * Core theory primitives: pitch, intervals, scales, chords, keys, meter, tuning
  * Timing model: raw vs grid layer types (shared with structure)
  * Shared error types and basic configuration enums

* `music-structure`

  * Phrase, cadence, motif, section, and full form modeling
  * `StructureGraph` and section/phrase templates
  * Template DSL compiled representation

* `music-analysis`

  * Orchestrated analysis engine (harmonic + structural)
  * Style rule-graph, planner (beam search), melodic engine
  * Explainability capture and formatting

* `music-api`

  * HTTP (REST) and streaming (SSE/WebSocket)
  * JSON models, run persistence abstractions, configuration parsing

* `music-cli`

  * Local dev/test tool for running analyses, benchmarks, and debugging

### 1.3. Module-level structure per crate

#### `crates/music-core/src`

* `lib.rs` — crate entry; feature flags; prelude
* `pitch/`

  * `mod.rs` — concrete/abstract pitch types
  * `tuning.rs` — tuning registry, systems
* `interval/`

  * `mod.rs` — interval ratios, validations
* `scale/`

  * `mod.rs` — scale descriptors, modes
* `chord/`

  * `mod.rs` — chord qualities, spellings
  * `function.rs` — harmonic function types
* `key/`

  * `mod.rs` — key signatures, modulations
* `meter/`

  * `mod.rs` — meter representation, swing markers
* `time/`

  * `raw.rs` — `RawNote`, `RawTrack`, `RawSession`
  * `grid.rs` — snapped events, swing inference, timing deltas
* `error.rs` — shared `MusicCoreError`

#### `crates/music-structure/src`

* `lib.rs`
* `phrase.rs` — phrase boundaries, functions, cadences
* `section.rs` — section definitions, roles (A/B/bridge, etc.)
* `graph.rs` — `StructureGraph` and relationships
* `template/`

  * `dsl.rs` — JSON5/RON DSL structs (serde)
  * `validate.rs` — DSL validation routines
  * `compile.rs` — DSL → `SectionTemplate`
  * `registry.rs` — template storage and lookup
* `tension.rs` — tension curves, bar mapping
* `error.rs` — `TemplateError`, `StructureError`

#### `crates/music-analysis/src`

* `lib.rs`
* `config.rs` — analysis config, style profile, creativity controls
* `features.rs` — low-level feature extraction (chord/key/meter evidence)
* `harmonic/`

  * `tracker.rs` — harmonic event timeline (chords, keys, confidence)
  * `evaluation.rs` — scoring candidate progressions
* `style/`

  * `graph.rs` — rule-graph types (global/context/move/weight/constraint/transform)
  * `presets.rs` — built-in styles (jazz, neo-soul, funk, etc.)
* `planner/`

  * `state.rs` — harmonic state representation (key, function, chord, bar, tension, phrase progress)
  * `beam.rs` — beam search engine with pruning
  * `rules.rs` — transitions, modulations, cadence enforcement
* `melody/`

  * `motif.rs` — motif representation and generation
  * `engine.rs` — harmony-derived melodic engine
* `explain/`

  * `capture.rs` — internal trace collection
  * `render.rs` — explainability payload formatting (none/brief/detailed/debug)
* `error.rs` — `AnalysisError`

#### `crates/music-api/src`

* `lib.rs`
* `config.rs` — API configuration, environment, limits
* `http/`

  * `mod.rs` — router setup
  * `handlers.rs` — REST endpoints: `/v1/analyze`, `/v1/runs/{id}`, etc.
* `streaming/`

  * `sse.rs` — SSE handler for `/v1/analyze/stream`
  * `ws.rs` — WebSocket endpoint `/ws/analyze`
* `models/`

  * `request.rs` — external JSON request structures
  * `response.rs` — external JSON response structures
* `persistence/`

  * `mod.rs` — `RunStore` trait
  * `memory.rs` — in-memory implementation
  * `db.rs` — placeholder for external DB (feature gated)
* `error.rs` — API errors mapped to HTTP

#### `crates/music-cli/src`

* `main.rs` — clap CLI entry, subcommands
* `commands/`

  * `analyze.rs` — run a local analysis and print summary
  * `bench.rs` — run timing benchmarks
  * `templates.rs` — validate/compile templates

### 1.4. Code quality guardrails

* Max ~300–400 LOC per file; split by submodule when exceeded.
* Tests live in `mod_name/tests.rs` or `tests/mod_name_*.rs` for integration.
* Test names follow `should_*` convention.
* No `unwrap`/`expect` in non-test code.
* Explicit error enums per crate.

---

## 2. Implementation Phasing

### Phase 1 — Core Theory & Timing Layer (`music-core`)

**Goal:** Stable, well-tested core theory and timing layer used by all other crates.

#### 2.1. Data structures

* `Pitch`, `AbstractPitch`, `TuningId`, `TuningRegistry`
* `Interval` with validation (non-finite, non-positive errors)
* `Scale`, `Mode`, `ScaleDegree`
* `ChordSymbol`, `ChordQuality`, `HarmonicFunction`
* `Key`, `KeyCenter`, `ModeKey`
* `Meter`, `BeatUnit`, `Swing` enum
* `RawNote`, `RawTrack`, `RawSession`
* `GridNote`, `GridTrack`, `GridSession` with `timing_delta`

#### 2.2. Functions/traits

* `impl Pitch` construction, transposition, comparison
* `Scale::from_root_and_mode` and chord generation helpers
* `Key::detect` baseline algorithm from pitch histogram (symbolic only)
* `Meter::infer` from barline metadata or note patterns (symbolic context)
* `RawSession::to_grid(config)` — snapping + swing detection

#### 2.3. Performance & correctness

* Zero-allocation tight loops where possible (iterators over slices)
* Fuzz tests for interval and pitch conversions
* Golden tests for scale/chord spelling

**Exit criteria:**

* All core types stable and documented.
* Grid conversion reliable on synthetic cases.

### Phase 2 — Structure Modeling (`music-structure`)

**Goal:** Represent phrases, sections, and full `StructureGraph` using grid events.

#### 2.4. Data structures

* `PhraseId`, `SectionId`
* `Phrase` (start_bar, end_bar, expected_functions, cadence_type)
* `Section` (role, bar_range, phrases)
* `StructureGraph` (sections, edges, metadata)
* `SectionTemplate` (compiled template with per-bar expectations)

#### 2.5. Functions/traits

* Basic heuristics: `StructureGraph::from_grid_session` (naive detector) for v1
* Helper methods: `section.phrase_at_bar`, `structure.bar_tension_target(bar)`

**Exit criteria:**

* Internal representation matches design (tension curve, phrases, cadences).
* Roundtrip tests with small manual examples.

### Phase 3 — Template DSL & Registry (`music-structure`)

**Goal:** Allow external JSON5/RON templates and compile them into `SectionTemplate`.

#### 3.1. DSL

* `dsl::Template` (bars, phrases, tension, cadence, modulations, constraints, reharm zones)
* Serde-based (JSON5/RON support via feature flags).

#### 3.2. Validation

* Non-overlapping phrases
* Tension curve matches bar count
* Valid bar indices and cadences
* Legal constraints (no impossible combinations)

#### 3.3. Compilation

* `compile(dsl::Template) -> Result<SectionTemplate, TemplateError>`
* Precompute per-bar expectations (function ranges, tension windows).

#### 3.4. Registry

* `TemplateRegistry` with in-memory store:

  * `insert(template_raw) -> id`
  * `get(id) -> Option<SectionTemplate>`
  * `list()` and `delete(id)`

**Exit criteria:**

* End-to-end tests: DSL → validate → compile → registry.
* Error messages suitable for API exposure.

### Phase 4 — Harmonic Feature Extraction (`music-analysis`)

**Goal:** Produce a harmonic timeline from grid data.

#### 4.1. Data structures

* `HarmonicEvent` (bar, beat, chord, key, confidence)
* `HarmonicTimeline` (Vec<HarmonicEvent>)

#### 4.2. Functions

* `extract_features(grid_session) -> FeatureSet`
* `estimate_keys(feature_set, style_profile)`
* `detect_chords(feature_set, style_profile)`

**Exit criteria:**

* Deterministic behavior across runs.
* Golden tests on curated MIDI snippets (simple cadences, II–V–I, blues, etc.).

### Phase 5 — Style Rule-Graph (`music-analysis`)

**Goal:** Implement rule-graph engine defining allowed harmonic moves per style.

#### 5.1. Data structures

* `StyleId`
* `StyleRuleGraph` with node/edge definitions:

  * Global rules
  * Context rules
  * Move rules
  * Weight rules
  * Constraint rules
  * Transform rules

#### 5.2. Functions

* Builders for built-in styles (jazz, neo-soul, funk, gospel, fusion)
* API to query allowed moves and weights:

  * `graph.next_states(current_state, context) -> impl Iterator<Item = CandidateState>`

**Exit criteria:**

* At least one fully implemented style (jazz/neo-soul hybrid) with tests.

### Phase 6 — Harmonic Planner (Beam Search) (`music-analysis`)

**Goal:** Plan 4–8 bar harmonic sequences respecting templates and style rules.

#### 6.1. Data structures

* `PlannerConfig` (beam_width, max_depth, tension_profile, etc.)
* `HarmonicState` (key, function, chord, bar_idx, tension, phrase_progress)
* `PlanResult` (sequence of `HarmonicState` + scores + explain traces)

#### 6.2. Functions

* `plan_section(template: &SectionTemplate, style: &StyleRuleGraph, config, seed_context) -> PlanResult`
* Beam search implementation with:

  * Score aggregation (tension matching, cadence fit, style weights)
  * Pruning rules (top-k, early termination conditions)

**Exit criteria:**

* Produces musically coherent progressions on known templates.
* Deterministic for same seed/config.

### Phase 7 — Melodic Engine (`music-analysis`)

**Goal:** Generate harmony-derived motifs and short melodic lines.

#### 7.3. Data structures

* `Motif` (relative scale degrees, rhythm pattern, accent pattern)
* `MelodicLine` (sequence of pitched events in bar/beat space)

#### 7.4. Functions

* `generate_motifs(plan_result, config) -> Vec<Motif>`
* `render_melody(motifs, plan_result, config) -> MelodicLine`

**Exit criteria:**

* Motifs follow tension curve and cadence behavior.
* Explainability traces reference scale degrees and chord tones.

### Phase 8 — Explainability Layer (`music-analysis`)

**Goal:** Attach structured explainability payloads to analysis results.

#### 8.1. Data structures

* `ExplainMode` (none, brief, detailed, debug)
* `ExplainTrace` (template_id, rules_fired, tension_targets, voice_leading, reharms, cadences)

#### 8.2. Functions

* `ExplainCapture` internal hooks in planner, style graph, melody engine
* `render_explain(trace, mode) -> ExplainPayload`

**Exit criteria:**

* Explain payloads are stable and JSON-serializable.
* Unit tests ensure no panics when mode toggles.

### Phase 9 — Orchestrated Analysis Engine (`music-analysis`)

**Goal:** Single orchestrator function wiring all previous phases.

#### 9.1. Entry point

* `run_analysis(config: AnalysisConfig, input: InputSession, template: SectionTemplate, style: StyleRuleGraph) -> AnalysisResult`

#### 9.2. Pipeline steps

1. Convert raw → grid (via `music-core`).
2. Extract harmonic features.
3. Estimate keys/chords baseline.
4. Run planner for target section(s).
5. Generate motifs/melody.
6. Capture explainability.
7. Assemble `AnalysisResult`.

**Exit criteria:**

* Integration tests verifying end-to-end pipeline on small examples.

### Phase 10 — API Layer (`music-api`)

**Goal:** Expose HTTP + streaming interfaces over the analysis engine.

#### 10.1. REST endpoints

* `POST /v1/analyze`

  * Body: input session (symbolic/MIDI), analysis config, template id, style id
  * Response: `AnalysisResult` JSON
* `GET /v1/runs/{id}`

  * Fetch persisted analysis
* `GET /v1/templates`
* `POST /v1/templates`
* `GET /v1/presets`
* `GET /v1/health`

#### 10.2. Streaming endpoints

* `POST /v1/analyze/stream` (SSE)

  * Events: `start`, `progress`, `update`, `completed`, `error`
* `/ws/analyze` (WebSocket)

  * Messages: `start`, `progress`, `update`, `completed`, `cancel`

#### 10.3. Persistence

* `RunStore` trait with in-memory implementation for v1:

  * `store(AnalysisResult) -> RunId`
  * `get(RunId) -> Option<StoredRun>`

**Exit criteria:**

* End-to-end tests (API → engine → response).
* Health check suitable for deployment.

### Phase 11 — CLI Tooling (`music-cli`)

**Goal:** Local developer and power-user tooling.

#### 11.1. Commands

* `music analyze` — run analysis from file/stdin, print summary or JSON
* `music bench` — run repeated analyses and report timing stats
* `music templates validate` — validate DSL files
* `music templates compile` — compile DSL → internal template JSON

**Exit criteria:**

* CLI integrated into dev workflow (used in CI tests/benches).

---

## 3. Cross-Cutting Concerns

### 3.1. Error model

* Dedicated error enums per crate (`CoreError`, `TemplateError`, `AnalysisError`, `ApiError`).
* Top-level conversion into API-safe error shapes.

### 3.2. Configuration & limits

* Global defaults for event caps, beam widths, timeout budgets.
* Tunable via API/CLI, but safe defaults chosen for v1.

### 3.3. Performance & parallelization

* Planner: multi-threaded option behind feature flag (using `rayon` or similar).
* Avoid unnecessary clones; prefer `Arc` for shared templates/styles.
* Benchmarks per phase (core, planner, full engine).

### 3.4. Explainability hooks

* All major decision points expose small, cheap hooks to `ExplainCapture`.
* Debug mode behind feature flag to avoid perf impact.

### 3.5. Versioning & compatibility

* Semantic versioning starting at `0.1.0` for v1 private beta.
* API version fixed at `/v1/...` with JSON schemas documented.

---

## 4. Phase-wise Deliverables Summary

For each phase:

* Concrete Rust modules/files created or extended.
* Tests:

  * Unit tests for new data structures and algorithms.
  * Integration tests for crate-level behavior.
* Benchmarks where performance-sensitive.
* Documentation:

  * Module-level rustdoc comments.
  * High-level crate README updates.

---

## 5. Readiness to Start Coding

Once this implementation plan is accepted:

1. Scaffold workspace and crates.
2. Implement Phase 1 & 2 (core + structure) with tests.
3. Iterate sequentially through phases, keeping integration tests green.
4. Use `music-cli` and golden tests as guardrails for theory correctness and regression.

This document should be kept in sync with actual implementation as the **single source of truth** for the build sequence and crate/module boundaries.
